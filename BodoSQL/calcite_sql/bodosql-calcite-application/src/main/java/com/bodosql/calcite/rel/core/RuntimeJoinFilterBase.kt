package com.bodosql.calcite.rel.core

import com.bodosql.calcite.adapter.bodo.BodoPhysicalRel
import com.bodosql.calcite.adapter.bodo.BodoPhysicalRuntimeJoinFilter
import com.bodosql.calcite.ir.BodoEngineTable
import com.bodosql.calcite.ir.Expr
import com.bodosql.calcite.ir.Op
import com.bodosql.calcite.plan.makeCost
import com.bodosql.calcite.prepare.NonEqualityJoinFilterColumnInfo
import org.apache.calcite.plan.RelOptCluster
import org.apache.calcite.plan.RelOptCost
import org.apache.calcite.plan.RelOptPlanner
import org.apache.calcite.plan.RelTraitSet
import org.apache.calcite.rel.RelNode
import org.apache.calcite.rel.RelWriter
import org.apache.calcite.rel.SingleRel
import org.apache.calcite.rel.metadata.RelMetadataQuery

/**
 * Base implementation for a runtime join filter.
 * See the design here:
 * https://bodo.atlassian.net/wiki/spaces/B/pages/1632370739/Runtime+Join+Filters#BodoPhysicalRuntimeJoinFilter
 *
 * For join ID, we store 1 value per left key in the source join. This ordering matters and is consistent as it
 * maps to each key location in the runtime join.
 *
 * In addition, we also store information for each joins about filters that are generated by non-equality join
 * conditions. For example, for interval joins we might store that a probe column must bigger than the min
 * of 1 build column and smaller than the max of another build column.
 *
 */
open class RuntimeJoinFilterBase(
    cluster: RelOptCluster,
    traits: RelTraitSet,
    input: RelNode,
    val joinFilterIDs: List<Int>,
    val equalityFilterColumns: List<List<Int>>,
    val equalityIsFirstLocations: List<List<Boolean>>,
    val nonEqualityFilterInfo: List<List<NonEqualityJoinFilterColumnInfo>>,
) : SingleRel(cluster, traits, input) {
    /**
     * Return a new RuntimeJoinFilterBase with only a different set of columns.
     */
    open fun copy(
        traitSet: RelTraitSet,
        input: RelNode,
        newEqualityColumns: List<List<Int>>,
        newNonEqualityColumns: List<List<NonEqualityJoinFilterColumnInfo>>,
    ): RuntimeJoinFilterBase {
        throw UnsupportedOperationException("Runtime Join Filter implementation must extend copy")
    }

    override fun explainTerms(pw: RelWriter): RelWriter {
        // Only display the new columns to avoid confusion in the plans.
        val displayedColumns =
            equalityFilterColumns.withIndex().map {
                    (idx, columns) ->
                columns.withIndex().filter { equalityIsFirstLocations[idx][it.index] }.map { it.value }
            }
        val allKeysReady = equalityFilterColumns.map { colList -> colList.all { it != -1 } }

        return pw.item("input", getInput())
            .item("joinIDs", joinFilterIDs)
            .item("equalityColumnsList", displayedColumns)
            .itemIf("allEqualityKeysReady", allKeysReady, allKeysReady.any())
            .item("nonEqualityColumnsList", nonEqualityFilterInfo)
    }

    override fun computeSelfCost(
        planner: RelOptPlanner,
        mq: RelMetadataQuery,
    ): RelOptCost {
        val rows = mq.getRowCount(this)
        return planner.makeCost().multiplyBy(rows)
    }

    companion object {
        /**
         * Generates the expression to pass in a tuple of runtime join filters
         * to an I/O call. The tuple contains tuples in the form
         * (joinState, filterColumns, nonEqualityOperators).
         */
        fun getRuntimeJoinFilterTuple(
            ctx: BodoPhysicalRel.BuildContext,
            runtimeJoinFilters: List<RuntimeJoinFilterBase>,
        ): Expr {
            if (runtimeJoinFilters.isEmpty()) return Expr.None
            val rtjfExprs: MutableList<Expr> = mutableListOf()
            // Iterate across each RuntimeJoinFilter node
            runtimeJoinFilters.forEach { rtjfCollection ->
                rtjfCollection.joinFilterIDs.forEachIndexed { idx, joinFilterId ->
                    val joinStateCache = ctx.builder().getJoinStateCache()
                    val joinCacheData = joinStateCache.getStreamingJoinInfo(joinFilterId)
                    val stateVar = joinCacheData.stateVariable
                    val keyLocations = joinCacheData.keyMapping
                    val nonKeyMapping = joinCacheData.nonEqualityMapping
                    val numProbeCols = joinCacheData.numProbeCols
                    val nKeyColumns = keyLocations.size
                    // If we don't have the state stored assume we have disabled
                    // streaming entirely and this is a no-op.
                    stateVar.let {
                        val columnOrderedList = MutableList(nKeyColumns) { Expr.NegativeOne }
                        keyLocations.forEachIndexed { index, keyLocation ->
                            columnOrderedList[keyLocation] =
                                Expr.IntegerLiteral(rtjfCollection.equalityFilterColumns[idx][index])
                        }
                        val columnsTuple = Expr.Tuple(columnOrderedList)
                        val tupleVar = ctx.lowerAsMetaType(columnsTuple)
                        // Generate the non-equality columns. Each non-equality is of the form
                        // Tuple(probe, build, operator)
                        val nonEqualityTupleList =
                            rtjfCollection.nonEqualityFilterInfo[idx].map {
                                val probe = Expr.IntegerLiteral(it.columnIndex)
                                val build = Expr.IntegerLiteral(nonKeyMapping[it.originalJoinBuildIndex]!! - numProbeCols)
                                val operator = Expr.StringLiteral(it.type.toString())
                                Expr.Tuple(probe, build, operator)
                            }
                        val nonEqualityTuple = Expr.Tuple(nonEqualityTupleList)
                        val nonEqualityTupleVar = ctx.lowerAsMetaType(nonEqualityTuple)
                        val rfjExpr = Expr.Tuple(stateVar, tupleVar, nonEqualityTupleVar)
                        rtjfExprs.add(rfjExpr)
                    }
                }
            }
            return Expr.Tuple(rtjfExprs)
        }

        /**
         * Wrap a reader result in runtime join filter codegen
         *
         * @param rel The original RelNode generating the read call.
         * @param ctx The build context.
         * @param runtimeJoinFilters The filters being applied.
         * @param readerResult The expression generated from the reader call.
         */
        fun wrapResultInRuntimeJoinFilters(
            rel: RelNode,
            ctx: BodoPhysicalRel.BuildContext,
            runtimeJoinFilters: List<RuntimeJoinFilterBase>,
            readerResult: Expr,
        ): BodoEngineTable {
            val builder = ctx.builder()
            var result = readerResult
            runtimeJoinFilters.forEach { it ->
                val joinFilters =
                    it.joinFilterIDs.indices.map { idx ->
                        Triple(it.joinFilterIDs[idx], it.equalityFilterColumns[idx], it.equalityIsFirstLocations[idx])
                    }
                val sortedJoinFilters = joinFilters.sortedByDescending { it.first }
                val joinFilterIDs = sortedJoinFilters.map { it.first }
                val columnsLists = sortedJoinFilters.map { it.second }
                val isFirstLocationLists = sortedJoinFilters.map { it.third }

                val rtjfResult =
                    BodoPhysicalRuntimeJoinFilter.generateRuntimeJoinFilterCode(
                        ctx,
                        joinFilterIDs,
                        columnsLists,
                        isFirstLocationLists,
                        result,
                    )
                rtjfResult?.let {
                    val tableChunkVar = builder.symbolTable.genTableVar()
                    builder.add(Op.Assign(tableChunkVar, rtjfResult))
                    result = tableChunkVar
                }
            }
            return BodoEngineTable(result.emit(), rel)
        }
    }
}
