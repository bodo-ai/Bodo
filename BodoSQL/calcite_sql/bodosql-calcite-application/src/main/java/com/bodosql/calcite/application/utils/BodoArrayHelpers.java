package com.bodosql.calcite.application.utils;

import com.bodosql.calcite.application.BodoSQLCodegenException;
import com.bodosql.calcite.ir.Expr;
import java.util.Objects;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.sql.type.SqlTypeName;

public class BodoArrayHelpers {

  /**
   * Takes a sql type, and a string length, and returns a string representing the appropriate
   * nullable array, allocated using bodo helper functions. Will upcast the type to the maximum bit
   * width.
   *
   * @param len String length expression
   * @param typ SqlType
   * @param defaultTzExpr Expression representing the default timezone
   * @return A string representation of the allocated bodo array with the specified length
   */
  public static String sqlTypeToNullableBodoArray(String len, RelDataType typ, Expr defaultTzExpr) {
    // TODO: Use nullable information to optimize on if the output can contain NULLs.
    SqlTypeName typeName = typ.getSqlTypeName();
    switch (typeName) {
      case BOOLEAN:
        return String.format("bodo.libs.bool_arr_ext.alloc_bool_array(%s)", len);
      case TINYINT:
      case SMALLINT:
      case INTEGER:
      case BIGINT:
        return String.format("bodo.libs.int_arr_ext.alloc_int_array(%s, bodo.types.int64)", len);
      case FLOAT:
      case DOUBLE:
      case DECIMAL:
        return String.format(
            "bodo.libs.float_arr_ext.alloc_float_array(%s, bodo.types.float64)", len);
      case DATE:
        return String.format("bodo.hiframes.datetime_date_ext.alloc_datetime_date_array(%s)", len);
      case TIMESTAMP:
        return String.format("np.empty(%s, dtype=\"datetime64[ns]\")", len);
      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
        String tzStr = defaultTzExpr.emit();
        return String.format(
            "bodo.libs.pd_datetime_arr_ext.alloc_pd_datetime_array(%s, %s)", len, tzStr);
      case INTERVAL_DAY_HOUR:
      case INTERVAL_DAY_MINUTE:
      case INTERVAL_DAY_SECOND:
      case INTERVAL_HOUR_MINUTE:
      case INTERVAL_HOUR_SECOND:
      case INTERVAL_MINUTE_SECOND:
      case INTERVAL_HOUR:
      case INTERVAL_MINUTE:
      case INTERVAL_SECOND:
      case INTERVAL_DAY:
        return String.format("np.empty(%s, dtype=\"timedelta64[ns]\")", len);
      case CHAR:
      case VARCHAR:
        return String.format("bodo.libs.str_arr_ext.pre_alloc_string_array(%s, -1)", len);
      case BINARY:
      case VARBINARY:
        return String.format("bodo.libs.str_arr_ext.pre_alloc_binary_array(%s, -1)", len);
      case TIME:
        int precision = typ.getPrecision();
        return String.format("bodo.hiframes.time_ext.alloc_time_array(%s, %d)", len, precision);
      default:
        throw new BodoSQLCodegenException(
            "Error, type: " + typ.toString() + " not supported for Window Aggregation functions");
    }
  }

  /**
   * Generate a String that matches the Bodo array type generated by the given type. This produces a
   * different array type depending on if the input is nullable.
   *
   * @param type SQL type for which we are generating the array.
   * @param strAsDict Should string types output a dictionary encoded array as opposed to a regular
   *     string array.
   * @param defaultTzExpr Expression representing the default timezone
   * @return A string that can be provided to generate code for the corresponding array type. This
   *     will be lowered as a global when we JIT compile the code.
   */
  public static Expr sqlTypeToBodoArrayType(
      RelDataType type, boolean strAsDict, Expr defaultTzExpr) {
    boolean nullable = type.isNullable();
    // TODO: Create type exprs
    final String typeName;
    switch (type.getSqlTypeName()) {
      case OTHER:
        typeName = "numba.types.unknown";
        break;
      case NULL:
        typeName = "bodo.types.null_array_type";
        break;
      case MAP:
        typeName =
            String.format(
                "bodo.MapArrayType(%s, %s)",
                sqlTypeToBodoArrayType(
                        Objects.requireNonNull(type.getKeyType()), false, defaultTzExpr)
                    .emit(),
                sqlTypeToBodoArrayType(
                        Objects.requireNonNull(type.getValueType()), false, defaultTzExpr)
                    .emit());
        break;
      case ARRAY:
        typeName =
            String.format(
                "bodo.ArrayItemArrayType(%s)",
                sqlTypeToBodoArrayType(
                        Objects.requireNonNull(type.getComponentType()), false, defaultTzExpr)
                    .emit());
        break;
      case BOOLEAN:
        // TODO: Add nullable support in the type
        typeName = "bodo.boolean_array_type";
        break;
      case TINYINT:
        // TODO: Add signed vs unsigned support
        if (nullable) {
          typeName = "bodo.IntegerArrayType(bodo.types.int8)";
        } else {
          typeName = "numba.core.types.Array(bodo.types.int8, 1, 'C')";
        }
        break;
      case SMALLINT:
        // TODO: Add signed vs unsigned support
        if (nullable) {
          typeName = "bodo.IntegerArrayType(bodo.types.int16)";
        } else {
          typeName = "numba.core.types.Array(bodo.types.int16, 1, 'C')";
        }
        break;
      case INTEGER:
        // TODO: Add signed vs unsigned support
        if (nullable) {
          typeName = "bodo.IntegerArrayType(bodo.types.int32)";
        } else {
          typeName = "numba.core.types.Array(bodo.types.int32, 1, 'C')";
        }
        break;
      case BIGINT:
        // TODO: Add signed vs unsigned support
        if (nullable) {
          typeName = "bodo.IntegerArrayType(bodo.types.int64)";
        } else {
          typeName = "numba.core.types.Array(bodo.types.int64, 1, 'C')";
        }
        break;
      case FLOAT:
        if (nullable) {
          typeName = "bodo.FloatingArrayType(bodo.types.float32)";
        } else {
          typeName = "numba.core.types.Array(bodo.types.float32, 1, 'C')";
        }
        break;
      case DOUBLE:
      case DECIMAL:
        if (nullable) {
          typeName = "bodo.FloatingArrayType(bodo.types.float64)";
        } else {
          typeName = "numba.core.types.Array(bodo.types.float64, 1, 'C')";
        }
        break;
      case DATE:
        typeName = "bodo.types.datetime_date_array_type";
        break;
      case TIMESTAMP:
        // TODO: Add nullable support
        typeName = "numba.core.types.Array(bodo.types.datetime64ns, 1, 'C')";
        break;
      case TIMESTAMP_WITH_LOCAL_TIME_ZONE:
        // TODO: Add nullable support
        typeName = String.format("bodo.DatetimeArrayType(%s)", defaultTzExpr.emit());
        break;
      case TIMESTAMP_TZ:
        typeName = "bodo.types.timestamptz_array_type";
        break;
      case TIME:
        // TODO: Add nullable support
        // TODO: Add precision support once Bodo stores value differently based on precision
        typeName = "bodo.types.TimeArrayType(9)";
        break;
      case VARCHAR:
      case CHAR:
        // TODO: Add nullable support
        if (strAsDict) {
          typeName = "bodo.dict_str_arr_type";
        } else {
          typeName = "bodo.types.string_array_type";
        }
        break;
      case VARBINARY:
      case BINARY:
        // TODO: Add nullable support
        typeName = "bodo.types.binary_array_type";
        break;
      case INTERVAL_DAY_HOUR:
      case INTERVAL_DAY_MINUTE:
      case INTERVAL_DAY_SECOND:
      case INTERVAL_HOUR_MINUTE:
      case INTERVAL_HOUR_SECOND:
      case INTERVAL_MINUTE_SECOND:
      case INTERVAL_HOUR:
      case INTERVAL_MINUTE:
      case INTERVAL_SECOND:
      case INTERVAL_DAY:
        // TODO: Add nullable support
        typeName = "numba.core.types.Array(bodo.types.timedelta64ns, 1, 'C')";
        break;
      case INTERVAL_YEAR:
      case INTERVAL_MONTH:
      case INTERVAL_YEAR_MONTH:
      // May later refactor this code to create DateOffsets, for now
      // causes an error
      default:
        throw new BodoSQLCodegenException(
            "Internal Error: Calcite Plan Produced an Unsupported Type: "
                + type.getSqlTypeName().getName());
    }
    return new Expr.Raw(typeName);
  }
}
