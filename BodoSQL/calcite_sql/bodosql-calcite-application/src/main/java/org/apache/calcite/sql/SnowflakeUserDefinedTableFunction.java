package org.apache.calcite.sql;

import com.bodosql.calcite.table.BodoSQLColumn;
import com.bodosql.calcite.table.ColumnDataTypeInfo;
import com.google.common.collect.ImmutableList;
import kotlin.Pair;
import org.apache.calcite.rel.type.RelDataType;
import org.apache.calcite.rel.type.RelDataTypeFactory;
import org.apache.calcite.schema.TableFunction;
import org.apache.calcite.sql.type.BodoTZInfo;
import org.checkerframework.checker.nullness.qual.Nullable;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import static com.bodosql.calcite.catalog.SnowflakeCatalog.snowflakeTypeNameToTypeInfo;

public class SnowflakeUserDefinedTableFunction extends SnowflakeUserDefinedBaseFunction implements TableFunction {
    // -- Fields --

    // Holds the return type information for the columns of the returned table.
    private final List<Pair<String, ColumnDataTypeInfo>> returnTypeInfo;


    /**
     * Creates a new Function for a call to a Snowflake User Defined Table Function.
     *
     * @param functionPath         The full path to this function including the function name.
     * @param args                 A string containing the args output from describe function.
     * @param numOptional          How many of the arguments are optional. Optional args must be at the end.
     * @param returns              A string containing the returns output from the describe function
     * @param body                 A string containing the body output from the describe function or NULL if the function is not a SQL UDF.
     * @param isSecure             Is the function a secure function?
     * @param isExternal           Is the function an external function?
     * @param language             What is the UDF's source language?
     * @param isMemoizable         Is the UDF memoizable?
     */
    protected SnowflakeUserDefinedTableFunction(ImmutableList<String> functionPath, String args, int numOptional, String returns, @Nullable String body, boolean isSecure, boolean isExternal, String language, boolean isMemoizable, BodoTZInfo tzInfo) {
        super("UDTF", functionPath, args, numOptional, body, isSecure, isExternal, language, isMemoizable, tzInfo);
        this.returnTypeInfo = parseReturnString(returns, tzInfo);
    }

    /**
     * Parses the return string generated from a Snowflake describe function into a format that can be used
     * for determined the return type. This string has the format:
     *
     * TABLE (COLUMN_NAME TYPE, COLUMN_NAME TYPE, ...)
     *
     * @param returns The string generated by a describe function call to Snowflake.
     * @param tzInfo The timezone information used for generating types.
     * @return A list of parsed values that represents each column in the table.
     */
    private List<Pair<String, ColumnDataTypeInfo>> parseReturnString(String returns, BodoTZInfo tzInfo) {
        // Note: Snowflake doesn't provide any escapes to delineate columns names.
        // For example if you column names were "BAD NAME1" and "BAD,NAME,2", the string
        // just looks like TABLE (BAD NAME1 VARCHAR, BAD,NAME,2 NUMBER). Therefor we cannot
        // do special handling for these cases and can only hope to provide some error checking.
        String errorMessage = String.format(
            Locale.ROOT,
    "Error encountered while resolving %s.%s.%s. Describe Function's \"returns\" metadata is improperly formatted or contains a type " +
            "Bodo does not yet support. Snowflake does not properly escape columns containing special characters like space " +
            "or comma in the metadata, which could be the source of failure.",
            getFunctionPath().get(0),
            getFunctionPath().get(1),
            getFunctionPath().get(2)
        );

        // Omit the leading TABLE ( and trailing )
        String strippedReturns = returns.substring("TABLE (".length(), returns.length() - 1);
        String[] columnParts = strippedReturns.split(",");
        ArrayList<Pair<String, ColumnDataTypeInfo>> columns = new ArrayList();
        for (String column: columnParts) {
            String[] parts = column.trim().split(" ");
            if (parts.length != 2) {
                throw new RuntimeException(errorMessage);
            } else {
                String name = parts[0];
                String type = parts[1];
                ColumnDataTypeInfo dataTypeInfo = snowflakeTypeNameToTypeInfo(type, true, tzInfo);
                if (dataTypeInfo.getDataType() == BodoSQLColumn.BodoSQLColumnDataType.UNSUPPORTED) {
                    throw new RuntimeException(errorMessage);
                }
                columns.add(new Pair(name, dataTypeInfo));
            }
        }
        return columns;
    }

    /**
     * Returns the record type of the table yielded by this function when
     * applied to given arguments. Only literal arguments are passed,
     * non-literal are replaced with default values (null, 0, false, etc).
     *
     * @param typeFactory Type factory
     * @param arguments   arguments of a function call (only literal arguments
     *                    are passed, nulls for non-literal ones)
     * @return row type of the table
     */
    @Override
    public RelDataType getRowType(RelDataTypeFactory typeFactory, List<?> arguments) {
        // Convert the pairs into lists for generating a row type.
        List<String> fieldNames = new ArrayList();
        List<RelDataType> fieldTypes = new ArrayList();
        for (Pair<String, ColumnDataTypeInfo> column: returnTypeInfo) {
            fieldNames.add(column.component1());
            fieldTypes.add(column.component2().convertToSqlType(typeFactory));
        }
        return typeFactory.createStructType(fieldTypes, fieldNames);
    }

    /**
     * Returns the row type of the table yielded by this function when
     * applied to given arguments. Only literal arguments are passed,
     * non-literal are replaced with default values (null, 0, false, etc).
     *
     * @param arguments arguments of a function call (only literal arguments
     *                  are passed, nulls for non-literal ones)
     * @return element type of the table (e.g. {@code Object[].class})
     */
    @Override
    public Type getElementType(List<?> arguments) {
        return Object[].class;
    }

    // -- static creators
    public static SnowflakeUserDefinedTableFunction create(ImmutableList<String> functionPath, String args, int numOptional, String returns, @Nullable String body, boolean isSecure, boolean isExternal, String language, boolean isMemoizable, BodoTZInfo tzInfo) {
        return new SnowflakeUserDefinedTableFunction(functionPath, args, numOptional, returns, body, isSecure, isExternal, language, isMemoizable, tzInfo);
    }
}
