parameters:
  name: ''
  vmImage: ''
  caching_test: false
  matrix: []

jobs:
- job: ${{ parameters.name }}
  timeoutInMinutes: 360
  variables:
    - group: SnowflakeCredentials
  pool:
    vmImage: ${{ parameters.vmImage }}
  strategy:
    maxParallel: 11
    matrix:
      ${{ insert }}: ${{ parameters.matrix }}

  steps:

  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.8'
    displayName: 'Use Python $(python.version)'

  - script: |
      set -eo pipefail
      if [[ "${{ parameters.name }}" == "Linux" || "${{ parameters.name }}" == "Linux_cache" ]]; then
        wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh
      else
        wget https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh -O miniconda.sh
      fi
      chmod +x miniconda.sh
      ./miniconda.sh -b
      export PATH=$HOME/miniconda3/bin:${PATH}
      conda create -y -n $CONDA_ENV python=3.9
      source activate $CONDA_ENV
    displayName: 'Download miniconda and create conda env'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:${PATH}
      source activate $CONDA_ENV
      if [[ "${{ parameters.useNumbaDev }}" == "true" ]]; then
        conda install -y numba -c numba/label/dev
        echo "Using Numba-Dev"
      else
        echo "Skipping..."
      fi
    displayName: 'Install Numba-Dev'

  - task: DownloadSecureFile@1
    name: secret_file
    displayName: 'Download secrets file'
    inputs:
      secureFile: 'publish_binary_secrets'

  - script: |
      set -eo pipefail
      sudo chmod a+r $(secret_file.secureFilePath)
      sudo cp $(secret_file.secureFilePath) $HOME/secret_file
      export PATH=$HOME/miniconda3/bin:${PATH}
      source activate $CONDA_ENV
      export CHECK_LICENSE_PLATFORM=$(CHECK_LICENSE_PLATFORM)
      export CHECK_LICENSE_EXPIRED=$(CHECK_LICENSE_EXPIRED)
      export OBFUSCATE=$(OBFUSCATE)
      if [[ "${{ parameters.platformBuild }}" == "true" ]]; then
        export PLATFORM_DEV_RELEASE=$(PLATFORM_DEV_RELEASE)
      else
        export PLATFORM_DEV_RELEASE="false"
      fi
      export BODO_VERSION=`python -c "import versioneer; print(versioneer.get_version())"`
      cd $(System.DefaultWorkingDirectory)
      ./buildscripts/azure/install_bodo.sh "${{ parameters.useNumbaDev }}" $BODO_VERSION $PLATFORM_DEV_RELEASE
    displayName: 'Install Bodo from conda'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:${PATH}
      source activate $CONDA_ENV
      conda list -f numba
    displayName: 'Check Numba Version'

  - script: |
      set -eo pipefail
      mkdir -p $HOME/bodo-inc
      cd $HOME/bodo-inc
      mkdir bodo
      if [[ "${{ parameters.name }}" == "Linux" || "${{ parameters.name }}" == "Linux_cache" ]]; then
        cp -avr $(System.DefaultWorkingDirectory)/bodo/tests bodo
      else
        cp -r $(System.DefaultWorkingDirectory)/bodo/tests bodo
      fi
    displayName: 'Copy test data'

  - script: |
      buildscripts/setup_minio.sh
    displayName: 'Setup minio'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:$PATH
      source activate $CONDA_ENV
      # s3fs is required by pandas for S3 IO
      # locking fsspec to 0.8 due to compatibility issues with s3fs
      # Cap the botocore version at 1.20.105 because 1.20.106 is incompatable
      # with fsspec.
      conda install -y -c conda-forge fsspec=0.8 boto3 botocore=1.20.105 s3fs
    displayName: 'Setup s3_testing'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:$PATH
      source activate $CONDA_ENV
      conda install -y -c conda-forge gcsfs
    displayName: 'Setup gcs_testing'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:$PATH
      source activate $CONDA_ENV
      pip install deltalake
    displayName: 'Setup deltalake testing'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:$PATH
      source activate $CONDA_ENV
      conda install -y -c conda-forge pymysql sqlalchemy snowflake-connector-python snowflake-sqlalchemy
    displayName: 'Setup MySQL testing'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:$PATH
      source activate $CONDA_ENV
      conda install -y -c conda-forge scikit-learn='1.0.*'
    displayName: 'Setup scikit-learn testing'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:$PATH
      source activate $CONDA_ENV
      conda install -y -c conda-forge xlrd xlsxwriter openpyxl
    displayName: 'Setup excel testing'

  - task: DownloadSecureFile@1
    name: testLicense
    displayName: 'Download test license'
    inputs:
      secureFile: 'bodo.lic'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:$PATH
      source activate $CONDA_ENV
      conda install -y 'matplotlib<=3.4.3' -c conda-forge
    displayName: 'Matplotlib'

  - script: |
      set -eo pipefail
      export PATH=$HOME/miniconda3/bin:$PATH
      source activate $CONDA_ENV
      conda install -y pyspark openjdk -c conda-forge
    displayName: 'PySpark'

  - script: |
      set -eo pipefail
      sudo chmod a+r $(testLicense.secureFilePath)
      sudo cp $(testLicense.secureFilePath) $HOME/bodo-inc
      export PATH=$HOME/miniconda3/bin:${PATH}
      source activate $CONDA_ENV
      pip install pytest pytest-azurepipelines
      cd $HOME/bodo-inc
      cp `python -c "import bodo; print(bodo.__file__[:-11])"`pytest.ini .
      if [[ "${{ parameters.caching_test }}" == "true" ]]; then
        python -m bodo.runtests_caching "$NP" bodo/tests/caching_tests
      elif [[ "$NP" -eq 3 ]] && [[ "${{ parameters.name }}" == "Linux" ]]; then
        python -m bodo.runtests "$NP" --pyargs bodo -s -v -m "$(PYTEST_MARKER)"
      else
        python -m bodo.runtests "$NP" --pyargs bodo -s -v -m "$(PYTEST_MARKER) and firsthalf"
        python -m bodo.runtests "$NP" --pyargs bodo -s -v -m "$(PYTEST_MARKER) and not firsthalf"
      fi
    env:
      SF_USER: $(SNOWFLAKE_USER)
      SF_PASSWORD: $(SNOWFLAKE_PASSWORD)
    displayName: 'Test Bodo'
